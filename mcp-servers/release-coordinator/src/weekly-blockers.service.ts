/**
 * Weekly Blockers Service
 * Compiles blocker tickets from the current week's test manager summary messages
 */

import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import path from 'path';

// Team label mapping - maps team display names to their Jira labels
const TEAM_LABEL_MAPPING: Record<string, string[]> = {
  'Expedite': ['Blocker'], // Priority blocker items
  'Corporate Learning': ['corporate-learning', 'coreteamx', 'KahootX'],
  'GameFactory': ['engaging-learning', 'GameFactory'],
  'SkynetTeam': ['SkynetTeam'],
  'PuzzlesTeam': ['PuzzlesTeam', 'DragonBox'],
  'Core3/Commercial': [
    'coreteam3', 'Coreteam3', 'commercial', 'Commercial',
    'onlineteam', 'onlineteam_IPM', 'marketplace', 'kahoot-remix'
  ],
};

export interface WeeklyBlockerTicket {
  key: string;
  url: string;
  summary: string;
  labels: string[];
  components: string[];
  parent?: {
    key: string;
    url: string;
  };
  status: string;
  daysAppeared: string[];
  team?: string;
}

export interface WeeklyBlockersReport {
  dateRange: { start: string; end: string };
  daysAnalyzed: number;
  ticketsByTeam: Map<string, WeeklyBlockerTicket[]>;
  uncategorized: WeeklyBlockerTicket[];
  totalTickets: number;
}

export class WeeklyBlockersService {
  private jiraBaseUrl: string;

  constructor(
    private dirname: string,
    private buildEnv: () => Record<string, string>
  ) {
    this.jiraBaseUrl = process.env.JIRA_BASE_URL || '';
  }

  /**
   * Generate the weekly blockers report
   * @param channel Slack channel to scan
   * @param weekOffset 0 = current week, -1 = previous week, etc.
   */
  async generateReport(channel: string = 'functional-testing', weekOffset: number = 0): Promise<WeeklyBlockersReport> {
    const { start, end, dates } = this.getWeekDateRange(weekOffset);

    // Collect all ticket IDs from test manager updates
    const ticketDaysMap = new Map<string, string[]>(); // ticketKey -> [dates]

    for (const date of dates) {
      const hotfixes = await this.fetchHotfixesForDate(channel, date);
      for (const ticketKey of hotfixes) {
        const existing = ticketDaysMap.get(ticketKey) || [];
        if (!existing.includes(date)) {
          existing.push(date);
        }
        ticketDaysMap.set(ticketKey, existing);
      }

      // On Fridays, also fetch from blocking issues analyzer
      // (test manager summary on Friday is typically "pipeline aborted" without blocker list)
      if (new Date(date + 'T12:00:00').getDay() === 5) {
        const fridayBlockers = await this.fetchBlockingIssuesForDate(channel, date);
        for (const ticketKey of fridayBlockers) {
          const existing = ticketDaysMap.get(ticketKey) || [];
          if (!existing.includes(date)) {
            existing.push(date);
          }
          ticketDaysMap.set(ticketKey, existing);
        }
      }
    }

    // Enrich tickets from Jira
    const tickets: WeeklyBlockerTicket[] = [];
    for (const [ticketKey, daysAppeared] of ticketDaysMap.entries()) {
      const enriched = await this.enrichTicketFromJira(ticketKey, daysAppeared);
      if (enriched) {
        tickets.push(enriched);
      }
    }

    // Group by team
    const ticketsByTeam = new Map<string, WeeklyBlockerTicket[]>();
    const uncategorized: WeeklyBlockerTicket[] = [];

    for (const ticket of tickets) {
      const team = this.findTeamForLabels(ticket.labels);
      ticket.team = team;

      if (team) {
        const teamTickets = ticketsByTeam.get(team) || [];
        teamTickets.push(ticket);
        ticketsByTeam.set(team, teamTickets);
      } else {
        uncategorized.push(ticket);
      }
    }

    return {
      dateRange: { start, end },
      daysAnalyzed: dates.length,
      ticketsByTeam,
      uncategorized,
      totalTickets: tickets.length,
    };
  }

  /**
   * Format the report for display
   */
  formatReport(report: WeeklyBlockersReport): string {
    const { dateRange, daysAnalyzed, ticketsByTeam, uncategorized, totalTickets } = report;

    if (totalTickets === 0) {
      return `*Weekly Blockers Report (${dateRange.start} - ${dateRange.end})*

No blockers reported this week.

---
_${daysAnalyzed} days analyzed_
_Generated by MCP Release Coordinator_`;
    }

    let output = `*Weekly Blockers Report (${dateRange.start} - ${dateRange.end})*\n\n`;

    // Sort teams for consistent output
    const sortedTeams = Array.from(ticketsByTeam.keys()).sort();

    for (const teamName of sortedTeams) {
      const teamTickets = ticketsByTeam.get(teamName)!;
      output += `*${teamName}* (${teamTickets.length} ticket${teamTickets.length !== 1 ? 's' : ''})\n`;

      for (const ticket of teamTickets) {
        output += this.formatTicketLine(ticket);
      }
      output += '\n';
    }

    if (uncategorized.length > 0) {
      output += `*Uncategorized* (${uncategorized.length} ticket${uncategorized.length !== 1 ? 's' : ''})\n`;
      for (const ticket of uncategorized) {
        output += this.formatTicketLine(ticket);
      }
      output += '\n';
    }

    output += `---
_${totalTickets} unique blocker${totalTickets !== 1 ? 's' : ''} from ${daysAnalyzed} days analyzed_
_Generated by MCP Release Coordinator_`;

    return output;
  }

  /**
   * Format a single ticket line
   */
  private formatTicketLine(ticket: WeeklyBlockerTicket): string {
    let line = `• <${ticket.url}|${ticket.key}> - ${ticket.summary}\n`;

    const details: string[] = [];

    if (ticket.labels.length > 0) {
      details.push(`${ticket.labels.join(', ')}`);
    }

    if (ticket.components.length > 0) {
      details.push(`${ticket.components.join(', ')}`);
    }

    if (ticket.parent) {
      details.push(`Parent: <${ticket.parent.url}|${ticket.parent.key}>`);
    }

    if (details.length > 0) {
      line += `  ${details.join(' | ')}\n`;
    }

    return line;
  }

  /**
   * Calculate the week date range
   * @param weekOffset 0 = current week, -1 = previous week, etc.
   * - Current week weekday: Monday → today
   * - Current week weekend or past weeks: Monday → Friday
   */
  private getWeekDateRange(weekOffset: number = 0): { start: string; end: string; dates: string[] } {
    const today = new Date();
    const dayOfWeek = today.getDay(); // 0=Sun, 1=Mon, ..., 6=Sat

    // Find Monday of this week
    const monday = new Date(today);
    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    monday.setDate(today.getDate() - daysFromMonday);

    // Apply week offset (negative = past weeks)
    monday.setDate(monday.getDate() + (weekOffset * 7));

    let endDate: Date;
    if (weekOffset === 0 && dayOfWeek >= 1 && dayOfWeek <= 5) {
      // Current week on a weekday: Mon-today
      endDate = new Date(today);
    } else {
      // Past week or weekend: Mon-Fri
      endDate = new Date(monday);
      endDate.setDate(monday.getDate() + 4);
    }

    // Generate all dates in range
    const dates: string[] = [];
    const current = new Date(monday);
    while (current <= endDate) {
      dates.push(this.formatDate(current));
      current.setDate(current.getDate() + 1);
    }

    return {
      start: this.formatDate(monday),
      end: this.formatDate(endDate),
      dates,
    };
  }

  /**
   * Format date as YYYY-MM-DD
   */
  private formatDate(date: Date): string {
    return date.toISOString().slice(0, 10);
  }

  /**
   * Fetch hotfix ticket IDs from test manager update for a specific date
   */
  private async fetchHotfixesForDate(channel: string, date: string): Promise<string[]> {
    const client = new Client({ name: 'weekly-blockers', version: '1.0.0' });
    const transport = new StdioClientTransport({
      command: 'node',
      args: ['dist/server.js'],
      cwd: path.resolve(this.dirname, '../../slack'),
      env: this.buildEnv(),
    });

    await client.connect(transport);
    try {
      const result = await client.callTool({
        name: 'get_test_manager_update',
        arguments: { channel, date },
      } as any);

      // Parse the response to extract hotfix tickets
      const text = this.extractTextContent(result) || '';
      return this.extractTicketKeysFromText(text);
    } catch (e: any) {
      console.error(`Error fetching TM update for ${date}:`, e?.message || String(e));
      return [];
    } finally {
      await client.close?.().catch(() => undefined);
    }
  }

  /**
   * Fetch blocking issues for a specific date (used for Fridays where TM summary doesn't list blockers)
   */
  private async fetchBlockingIssuesForDate(channel: string, date: string): Promise<string[]> {
    const client = new Client({ name: 'weekly-blockers', version: '1.0.0' });
    const transport = new StdioClientTransport({
      command: 'node',
      args: ['dist/server.js'],
      cwd: path.resolve(this.dirname, '../../slack'),
      env: this.buildEnv(),
    });

    await client.connect(transport);
    try {
      const result = await client.callTool({
        name: 'get_blocking_issues',
        arguments: { channel, date, severity: 'blocking' },
      } as any);

      // Parse the response to extract ticket keys
      const text = this.extractTextContent(result) || '';
      return this.extractTicketKeysFromText(text);
    } catch (e: any) {
      console.error(`Error fetching blocking issues for ${date}:`, e?.message || String(e));
      return [];
    } finally {
      await client.close?.().catch(() => undefined);
    }
  }

  /**
   * Extract JIRA ticket keys from text
   */
  private extractTicketKeysFromText(text: string): string[] {
    const pattern = /\b([A-Z][A-Z0-9]+-\d+)\b/g;
    const matches = text.match(pattern) || [];
    return [...new Set(matches)]; // Deduplicate
  }

  /**
   * Enrich a ticket with Jira details
   */
  private async enrichTicketFromJira(
    ticketKey: string,
    daysAppeared: string[]
  ): Promise<WeeklyBlockerTicket | null> {
    const client = new Client({ name: 'weekly-blockers', version: '1.0.0' });
    const transport = new StdioClientTransport({
      command: 'node',
      args: ['dist/server.js'],
      cwd: path.resolve(this.dirname, '../../jira'),
      env: this.buildEnv(),
    });

    await client.connect(transport);
    try {
      const result = await client.callTool({
        name: 'get_issue_details',
        arguments: { issueKey: ticketKey },
      } as any);

      const text = this.extractTextContent(result) || '';
      return this.parseJiraResponse(ticketKey, text, daysAppeared);
    } catch (e: any) {
      console.error(`Error fetching Jira details for ${ticketKey}:`, e?.message || String(e));
      // Return minimal ticket info even if Jira call fails
      return {
        key: ticketKey,
        url: `${this.jiraBaseUrl}/browse/${ticketKey}`,
        summary: '(Unable to fetch details)',
        labels: [],
        components: [],
        status: 'unknown',
        daysAppeared,
      };
    } finally {
      await client.close?.().catch(() => undefined);
    }
  }

  /**
   * Parse Jira response text to extract ticket details
   */
  private parseJiraResponse(
    ticketKey: string,
    text: string,
    daysAppeared: string[]
  ): WeeklyBlockerTicket {
    // Extract summary from first line (format: **KEY**: Summary)
    const summaryMatch = text.match(/\*\*[A-Z]+-\d+\*\*:\s*(.+?)(?:\n|$)/);
    const summary = summaryMatch ? summaryMatch[1].trim() : '';

    // Extract labels
    const labelsMatch = text.match(/Labels:\s*(.+?)(?:\n|$)/);
    const labelsText = labelsMatch ? labelsMatch[1].trim() : '';
    const labels = labelsText && labelsText !== 'None'
      ? labelsText.split(',').map(l => l.trim()).filter(Boolean)
      : [];

    // Extract components
    const componentsMatch = text.match(/Components:\s*(.+?)(?:\n|$)/);
    const componentsText = componentsMatch ? componentsMatch[1].trim() : '';
    const components = componentsText && componentsText !== 'None'
      ? componentsText.split(',').map(c => c.trim()).filter(Boolean)
      : [];

    // Extract status
    const statusMatch = text.match(/Status:\s*(.+?)(?:\n|$)/);
    const status = statusMatch ? statusMatch[1].trim() : 'unknown';

    // Extract parent if present (from the Jira response, if available)
    // Note: Standard get_issue_details may not include parent - this is a placeholder
    let parent: { key: string; url: string } | undefined;
    const parentMatch = text.match(/Parent:\s*\*?\*?([A-Z]+-\d+)\*?\*?/);
    if (parentMatch) {
      parent = {
        key: parentMatch[1],
        url: `${this.jiraBaseUrl}/browse/${parentMatch[1]}`,
      };
    }

    return {
      key: ticketKey,
      url: `${this.jiraBaseUrl}/browse/${ticketKey}`,
      summary,
      labels,
      components,
      parent,
      status,
      daysAppeared,
    };
  }

  /**
   * Find the team for a set of labels (first match wins)
   */
  private findTeamForLabels(labels: string[]): string | undefined {
    for (const [teamName, teamLabels] of Object.entries(TEAM_LABEL_MAPPING)) {
      if (labels.some(label => teamLabels.includes(label))) {
        return teamName;
      }
    }
    return undefined;
  }

  /**
   * Extract text content from MCP result
   */
  private extractTextContent(result: any): string | null {
    const items = result?.content || [];
    const textItem = items.find((c: any) => c?.type === 'text' && typeof c.text === 'string');
    return textItem?.text || null;
  }
}
